/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.apache.iotdb.cluster.partition;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apache.commons.collections4.map.MultiKeyMap;
import org.apache.iotdb.cluster.exception.UnsupportedPlanException;
import org.apache.iotdb.cluster.log.Log;
import org.apache.iotdb.cluster.log.logtypes.PhysicalPlanLog;
import org.apache.iotdb.cluster.rpc.thrift.Node;
import org.apache.iotdb.cluster.utils.PartitionUtils;
import org.apache.iotdb.db.engine.StorageEngine;
import org.apache.iotdb.db.exception.metadata.MetadataException;
import org.apache.iotdb.db.exception.metadata.StorageGroupNotSetException;
import org.apache.iotdb.db.metadata.MManager;
import org.apache.iotdb.db.qp.physical.PhysicalPlan;
import org.apache.iotdb.db.qp.physical.crud.*;
import org.apache.iotdb.db.qp.physical.sys.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * PartitionTable manages the map whose key is the StorageGroupName with a time interval and the
 * value is a PartitionGroup with contains all nodes that manage the corresponding data.
 */
public interface PartitionTable {
  // static final is not necessary, it is redundant for an interface
  Logger logger = LoggerFactory.getLogger(SlotPartitionTable.class);
  long PARTITION_INTERVAL = StorageEngine.getTimePartitionInterval();

  /**
   * Given the storageGroupName and the timestamp, return the list of nodes on which the storage
   * group and the corresponding time interval is managed.
   * @param storageGroupName
   * @param timestamp
   * @return
   */
  PartitionGroup route(String storageGroupName, long timestamp);

  /**
   * get a unicode value for a sg and a timestamp.
   * @param storageGroupName
   * @param timestamp
   * @return
   */
  int getHashKey(String storageGroupName, long timestamp);

  PartitionGroup route(int hashkey);
  /**
   * Add a new node to update the partition table.
   * @param node
   * @return the new group generated by the node
   */
  PartitionGroup addNode(Node node);

  /**
   *
   * @return All data groups where all VNodes of this node is the header. The first index
   * indicates the VNode and the second index indicates the data group of one VNode.
   */
  List<PartitionGroup> getLocalGroups();

  /**
   *
   * @param header
   * @return the partition group starting from the header.
   */
  PartitionGroup getHeaderGroup(Node header);

  ByteBuffer serialize();

  void deserialize(ByteBuffer buffer);

  List<Node> getAllNodes();

  /**
   *
   * @return each slot's previous holder after the node's addition.
   */
  Map<Integer, Node> getPreviousNodeMap(Node node);

  /**
   *
   * @param header
   * @return the slots held by the header.
   */
  List<Integer> getNodeSlots(Node header);

  Map<Node, List<Integer>> getAllNodeSlots();

  int getTotalSlotNumbers();

  default int calculateLogSlot(Log log) {
    if (log instanceof PhysicalPlanLog) {
      PhysicalPlanLog physicalPlanLog = ((PhysicalPlanLog) log);
      PhysicalPlan plan = physicalPlanLog.getPlan();
      String storageGroup = null;
      if (plan instanceof CreateTimeSeriesPlan) {
        try {
          storageGroup = MManager.getInstance()
              .getStorageGroupNameByPath(((CreateTimeSeriesPlan) plan).getPath().getFullPath());
          //timestamp is meaningless, use 0 instead.
          return PartitionUtils.calculateStorageGroupSlot(storageGroup, 0, this.getTotalSlotNumbers());
        } catch (MetadataException e) {
          logger.error("Cannot find the storage group of {}", ((CreateTimeSeriesPlan) plan).getPath());
          return -1;
        }
      } else if (plan instanceof InsertPlan || plan instanceof BatchInsertPlan) {
        try {
          storageGroup = MManager.getInstance()
              .getStorageGroupNameByPath(((InsertPlan) plan).getDeviceId());
        } catch (StorageGroupNotSetException e) {
          logger.error("Cannot find the storage group of {}", ((CreateTimeSeriesPlan) plan).getPath());
          return -1;
        }
      } else if (plan instanceof DeletePlan) {
        //TODO deleteplan may have many SGs.
        logger.error("not implemented for DeletePlan in cluster {}", plan);
        return -1;
      }

      return Math.abs(Objects.hash(storageGroup, 0));
    }
    return 0;
  }

  default PartitionGroup partitionPlan(PhysicalPlan plan)
      throws UnsupportedPlanException, StorageGroupNotSetException {
    //the if clause can be removed after the program is stable
    if (plan.canbeSplit()) {
      logger.error("{} can be split. call an incorrect partitionMethod");
    }
    throw new UnsupportedPlanException(plan);
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(PhysicalPlan plan)
      throws UnsupportedPlanException, StorageGroupNotSetException {
    //the if clause can be removed after the program is stable
    if (!plan.canbeSplit()) {
      logger.error("{} can be split. call an incorrect partitionMethod");
    }
    throw new UnsupportedPlanException(plan);
  }

  //CRUD
  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(AggregationPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(BatchInsertPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(DeletePlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(FillQueryPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(GroupByPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(InsertPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {
    return partitionByPathTime(plan.getDeviceId(), plan.getTime());
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(QueryPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(UpdatePlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {
    throw new UnsupportedPlanException(plan);
  }


  //SYS

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(AuthorPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(CountPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(CreateTimeSeriesPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {
    return partitionByPathTime(plan.getPath().getFullPath(), 0);
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(DataAuthPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(DeleteStorageGroupPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(DeleteTimeSeriesPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(LoadConfigurationPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(LoadDataPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(OperateFilePlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(PropertyPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(SetStorageGroupPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(SetTTLPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(ShowChildPathsPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(ShowDevicesPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {

    return null;
  }

  default PartitionGroup partitionPlan(ShowPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {
    //TODO this plan is duplicated with other show...
    logger.error("not implemented, {}", plan);
    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(ShowTimeSeriesPlan plan)
      throws UnsupportedPlanException,StorageGroupNotSetException {
    //show timeseries is quite special because it has the behavior of wildcard at the tail of the path
    // even though there is no wildcard

    return null;
  }

  default Map<PhysicalPlan, PartitionGroup> partitionPlanIntoMore(ShowTTLPlan plan) {
    Map<Integer, List<String>> stroageGroupTeams = new HashMap<>();
    for (String storageGroup : plan.getStorageGroups()) {
      int slot = getHashKey(storageGroup, 0);
      stroageGroupTeams.computeIfAbsent(slot, x ->new ArrayList<String>());
      stroageGroupTeams.get(slot).add(storageGroup);
    }
    Map<PhysicalPlan, PartitionGroup> result =new HashMap<>();
    for (Map.Entry<Integer, List<String>> entry : stroageGroupTeams.entrySet()) {
      result.put(new ShowTTLPlan(entry.getValue()), route(entry.getKey()));
    }
    return result;
  }

  /**
   * @param path can be an incomplete path (but should contain a storage group name)
   *              e.g., if  "root.sg" is a storage group, then path can not be "root".
   * @param timestamp
   * @return
   * @throws StorageGroupNotSetException
   */
  default PartitionGroup partitionByPathTime(String path, long timestamp)
      throws StorageGroupNotSetException {
    String storageGroup = MManager.getInstance().getStorageGroupNameByPath(path);
    return this.route(storageGroup, timestamp);
  }

  /**
   * Get partition info by path and range time
   *
   * @UsedBy NodeTool
   * @return (startTime, endTime) - partitionGroup pair
   */
  default  MultiKeyMap<Long, PartitionGroup> partitionByPathRangeTime(String path,
      long startTime, long endTime) throws StorageGroupNotSetException {
    MultiKeyMap<Long, PartitionGroup> timeRangeMapRaftGroup = new MultiKeyMap<>();
    String storageGroup = MManager.getInstance().getStorageGroupNameByPath(path);
    while (startTime <= endTime) {
      long nextTime = (startTime / PARTITION_INTERVAL + 1) * PARTITION_INTERVAL; //FIXME considering the time unit
      timeRangeMapRaftGroup.put(startTime, Math.min(nextTime - 1, endTime),
          this.route(storageGroup, startTime));
      startTime = nextTime;
    }
    return timeRangeMapRaftGroup;
  }

  default List<List<String>> splitPaths(List<String> paths) {
    return null;
  }
}
